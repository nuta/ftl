//! DO NOT EDIT: This file is auto-generated by ftl_idlc.
#![no_std]
#![feature(const_mut_refs)]
#![feature(const_intrinsic_copy)]
#![feature(const_ptr_write)]

use ftl_types::message::MessageBuffer;
use ftl_types::message::MessageDeserialize;
use ftl_types::message::MessageInfo;
use ftl_types::message::MessageSerialize;
use ftl_types::message::MovedHandle;

pub mod protocols {
    use super::*;

    pub mod autopilot {
        use super::*;

        #[repr(C)]

        pub struct NewclientRequest {
            // TODO: Don't copy whole bytes fields.
            pub handle: MovedHandle,
        }

        #[repr(C)]
        struct RawNewclientRequest {}

        impl MessageSerialize for NewclientRequest {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (1 << 14) | (1 << 12) | ::core::mem::size_of::<RawNewclientRequest>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<NewclientRequest>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: NewclientRequest, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawNewclientRequest;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(NewclientRequest::MSGINFO.as_raw()).num_handles()
                            <= 1
                    );

                    buffer.handles[0] = this.handle.0;

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for NewclientRequest {
            type Reader<'a> = NewclientRequestReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<NewclientRequestReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(NewclientRequestReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct NewclientRequestReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> NewclientRequestReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawNewclientRequest {
                unsafe { &*(buffer as *const _ as *const RawNewclientRequest) }
            }

            pub fn handle(&self) -> ftl_types::handle::HandleId {
                // TODO: return OwnedHandle
                // FIXME: Support multiple handles.
                self.buffer.handles[0]
            }
        }

        #[repr(C)]

        pub struct NewclientReply {
            // TODO: Don't copy whole bytes fields.
        }

        #[repr(C)]
        struct RawNewclientReply {}

        impl MessageSerialize for NewclientReply {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (2 << 14) | (0 << 12) | ::core::mem::size_of::<RawNewclientReply>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<NewclientReply>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: NewclientReply, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawNewclientReply;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(NewclientReply::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for NewclientReply {
            type Reader<'a> = NewclientReplyReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<NewclientReplyReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(NewclientReplyReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct NewclientReplyReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> NewclientReplyReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawNewclientReply {
                unsafe { &*(buffer as *const _ as *const RawNewclientReply) }
            }
        }
    }

    pub mod ping {
        use super::*;

        #[repr(C)]

        pub struct PingRequest<'a> {
            // TODO: Don't copy whole bytes fields.
            pub int_value1: i32,

            pub bytes_value1: &'a [u8],
        }

        #[repr(C)]
        struct RawPingRequest {
            pub int_value1: i32,

            pub bytes_value1: ftl_types::idl::BytesField<16>,
        }

        impl<'a> MessageSerialize for PingRequest<'a> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (3 << 14) | (0 << 12) | ::core::mem::size_of::<RawPingRequest>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<PingRequest>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: PingRequest, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawPingRequest;

                    unsafe {
                        core::ptr::write(&mut (*dst).int_value1, this.int_value1);
                    }

                    unsafe {
                        (*dst).bytes_value1.copy_from_slice(&this.bytes_value1);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(PingRequest::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl<'m> MessageDeserialize for PingRequest<'m> {
            type Reader<'a> = PingRequestReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<PingRequestReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(PingRequestReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct PingRequestReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> PingRequestReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawPingRequest {
                unsafe { &*(buffer as *const _ as *const RawPingRequest) }
            }

            pub fn int_value1(&self) -> i32 {
                let m = self.as_raw(self.buffer);
                m.int_value1
            }

            pub fn bytes_value1(&self) -> ftl_types::idl::BytesField<16> {
                let m = self.as_raw(self.buffer);
                m.bytes_value1
            }
        }

        #[repr(C)]

        pub struct PingReply {
            // TODO: Don't copy whole bytes fields.
            pub int_value2: i32,

            pub str_value2: ftl_types::idl::StringField<32>,
        }

        #[repr(C)]
        struct RawPingReply {
            pub int_value2: i32,

            pub str_value2: ftl_types::idl::StringField<32>,
        }

        impl MessageSerialize for PingReply {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (4 << 14) | (0 << 12) | ::core::mem::size_of::<RawPingReply>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<PingReply>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: PingReply, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawPingReply;

                    unsafe {
                        core::ptr::write(&mut (*dst).int_value2, this.int_value2);
                    }

                    unsafe {
                        core::ptr::write(&mut (*dst).str_value2, this.str_value2);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(PingReply::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for PingReply {
            type Reader<'a> = PingReplyReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<PingReplyReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(PingReplyReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct PingReplyReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> PingReplyReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawPingReply {
                unsafe { &*(buffer as *const _ as *const RawPingReply) }
            }

            pub fn int_value2(&self) -> i32 {
                let m = self.as_raw(self.buffer);
                m.int_value2
            }

            pub fn str_value2(&self) -> ftl_types::idl::StringField<32> {
                let m = self.as_raw(self.buffer);
                m.str_value2
            }
        }
    }

    pub mod ethernet_device {
        use super::*;

        #[repr(C)]

        pub struct Tx<'a> {
            // TODO: Don't copy whole bytes fields.
            pub payload: &'a [u8],
        }

        #[repr(C)]
        struct RawTx {
            pub payload: ftl_types::idl::BytesField<1514>,
        }

        impl<'a> MessageSerialize for Tx<'a> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (5 << 14) | (0 << 12) | ::core::mem::size_of::<RawTx>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<Tx>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: Tx, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTx;

                    unsafe {
                        (*dst).payload.copy_from_slice(&this.payload);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(MessageInfo::from_raw(Tx::MSGINFO.as_raw()).num_handles() <= 1);

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl<'m> MessageDeserialize for Tx<'m> {
            type Reader<'a> = TxReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TxReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TxReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TxReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TxReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTx {
                unsafe { &*(buffer as *const _ as *const RawTx) }
            }

            pub fn payload(&self) -> ftl_types::idl::BytesField<1514> {
                let m = self.as_raw(self.buffer);
                m.payload
            }
        }

        #[repr(C)]

        pub struct Rx<'a> {
            // TODO: Don't copy whole bytes fields.
            pub payload: &'a [u8],
        }

        #[repr(C)]
        struct RawRx {
            pub payload: ftl_types::idl::BytesField<1514>,
        }

        impl<'a> MessageSerialize for Rx<'a> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (6 << 14) | (0 << 12) | ::core::mem::size_of::<RawRx>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<Rx>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: Rx, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawRx;

                    unsafe {
                        (*dst).payload.copy_from_slice(&this.payload);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(MessageInfo::from_raw(Rx::MSGINFO.as_raw()).num_handles() <= 1);

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl<'m> MessageDeserialize for Rx<'m> {
            type Reader<'a> = RxReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<RxReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(RxReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct RxReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> RxReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawRx {
                unsafe { &*(buffer as *const _ as *const RawRx) }
            }

            pub fn payload(&self) -> ftl_types::idl::BytesField<1514> {
                let m = self.as_raw(self.buffer);
                m.payload
            }
        }
    }

    pub mod tcpip {
        use super::*;

        #[repr(C)]

        pub struct TcpClosed {
            // TODO: Don't copy whole bytes fields.
        }

        #[repr(C)]
        struct RawTcpClosed {}

        impl MessageSerialize for TcpClosed {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (7 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpClosed>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpClosed>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpClosed, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpClosed;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpClosed::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for TcpClosed {
            type Reader<'a> = TcpClosedReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpClosedReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpClosedReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpClosedReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpClosedReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpClosed {
                unsafe { &*(buffer as *const _ as *const RawTcpClosed) }
            }
        }

        #[repr(C)]

        pub struct TcpAccepted {
            // TODO: Don't copy whole bytes fields.
            pub sock: MovedHandle,
        }

        #[repr(C)]
        struct RawTcpAccepted {}

        impl MessageSerialize for TcpAccepted {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (8 << 14) | (1 << 12) | ::core::mem::size_of::<RawTcpAccepted>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpAccepted>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpAccepted, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpAccepted;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpAccepted::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    buffer.handles[0] = this.sock.0;

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for TcpAccepted {
            type Reader<'a> = TcpAcceptedReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpAcceptedReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpAcceptedReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpAcceptedReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpAcceptedReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpAccepted {
                unsafe { &*(buffer as *const _ as *const RawTcpAccepted) }
            }

            pub fn sock(&self) -> ftl_types::handle::HandleId {
                // TODO: return OwnedHandle
                // FIXME: Support multiple handles.
                self.buffer.handles[0]
            }
        }

        #[repr(C)]

        pub struct TcpReceived<'a> {
            // TODO: Don't copy whole bytes fields.
            pub data: &'a [u8],
        }

        #[repr(C)]
        struct RawTcpReceived {
            pub data: ftl_types::idl::BytesField<2048>,
        }

        impl<'a> MessageSerialize for TcpReceived<'a> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (9 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpReceived>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpReceived>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpReceived, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpReceived;

                    unsafe {
                        (*dst).data.copy_from_slice(&this.data);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpReceived::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl<'m> MessageDeserialize for TcpReceived<'m> {
            type Reader<'a> = TcpReceivedReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpReceivedReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpReceivedReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpReceivedReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpReceivedReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpReceived {
                unsafe { &*(buffer as *const _ as *const RawTcpReceived) }
            }

            pub fn data(&self) -> ftl_types::idl::BytesField<2048> {
                let m = self.as_raw(self.buffer);
                m.data
            }
        }

        #[repr(C)]

        pub struct TcpListenRequest {
            // TODO: Don't copy whole bytes fields.
            pub port: u16,
        }

        #[repr(C)]
        struct RawTcpListenRequest {
            pub port: u16,
        }

        impl MessageSerialize for TcpListenRequest {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (10 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpListenRequest>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpListenRequest>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpListenRequest, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpListenRequest;

                    unsafe {
                        core::ptr::write(&mut (*dst).port, this.port);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpListenRequest::MSGINFO.as_raw()).num_handles()
                            <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for TcpListenRequest {
            type Reader<'a> = TcpListenRequestReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpListenRequestReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpListenRequestReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpListenRequestReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpListenRequestReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpListenRequest {
                unsafe { &*(buffer as *const _ as *const RawTcpListenRequest) }
            }

            pub fn port(&self) -> u16 {
                let m = self.as_raw(self.buffer);
                m.port
            }
        }

        #[repr(C)]

        pub struct TcpListenReply {
            // TODO: Don't copy whole bytes fields.
        }

        #[repr(C)]
        struct RawTcpListenReply {}

        impl MessageSerialize for TcpListenReply {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (11 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpListenReply>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpListenReply>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpListenReply, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpListenReply;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpListenReply::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for TcpListenReply {
            type Reader<'a> = TcpListenReplyReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpListenReplyReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpListenReplyReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpListenReplyReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpListenReplyReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpListenReply {
                unsafe { &*(buffer as *const _ as *const RawTcpListenReply) }
            }
        }

        #[repr(C)]

        pub struct TcpSendRequest<'a> {
            // TODO: Don't copy whole bytes fields.
            pub data: &'a [u8],
        }

        #[repr(C)]
        struct RawTcpSendRequest {
            pub data: ftl_types::idl::BytesField<2048>,
        }

        impl<'a> MessageSerialize for TcpSendRequest<'a> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (12 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpSendRequest>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpSendRequest>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpSendRequest, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpSendRequest;

                    unsafe {
                        (*dst).data.copy_from_slice(&this.data);
                    }

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpSendRequest::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl<'m> MessageDeserialize for TcpSendRequest<'m> {
            type Reader<'a> = TcpSendRequestReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpSendRequestReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpSendRequestReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpSendRequestReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpSendRequestReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpSendRequest {
                unsafe { &*(buffer as *const _ as *const RawTcpSendRequest) }
            }

            pub fn data(&self) -> ftl_types::idl::BytesField<2048> {
                let m = self.as_raw(self.buffer);
                m.data
            }
        }

        #[repr(C)]

        pub struct TcpSendReply {
            // TODO: Don't copy whole bytes fields.
        }

        #[repr(C)]
        struct RawTcpSendReply {}

        impl MessageSerialize for TcpSendReply {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                (13 << 14) | (0 << 12) | ::core::mem::size_of::<RawTcpSendReply>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<TcpSendReply>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: TcpSendReply, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut RawTcpSendReply;

                    // FIXME: Support multiple handles.
                    debug_assert!(
                        MessageInfo::from_raw(TcpSendReply::MSGINFO.as_raw()).num_handles() <= 1
                    );

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        impl MessageDeserialize for TcpSendReply {
            type Reader<'a> = TcpSendReplyReader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<TcpSendReplyReader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some(TcpSendReplyReader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct TcpSendReplyReader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> TcpSendReplyReader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a RawTcpSendReply {
                unsafe { &*(buffer as *const _ as *const RawTcpSendReply) }
            }
        }
    }
}
