//! DO NOT EDIT: This file is auto-generated by ftl_idlc.
#![no_std]

pub use ftl_autogen::*;

pub mod apps {

    pub mod ping {
        pub struct Environ {
            pub depends: Depends,
        }

        impl Environ {
            pub fn from_environ_ptr(environ_ptr: *const u8, environ_len: usize) -> Self {
                let environ_bytes =
                    unsafe { ::core::slice::from_raw_parts(environ_ptr, environ_len) };

                #[allow(unused_variables)]
                let environ_json: EnvironJson =
                    serde_json::from_slice(environ_bytes).expect("failed to parse environ JSON");

                let depends = Depends {
                    ping_server: {
                        use ftl_api::channel::Channel;
                        use ftl_api::handle::OwnedHandle;
                        use ftl_types::handle::HandleId;

                        let handle_id = HandleId::from_raw(environ_json.depends.ping_server);
                        let handle = OwnedHandle::from_raw(handle_id);
                        Some(Channel::from_handle(handle))
                    },
                };

                Self { depends }
            }
        }

        pub struct Depends {
            pub ping_server: Option<ftl_api::channel::Channel>,
        }

        #[derive(serde::Serialize, serde::Deserialize)]
        struct EnvironJson {
            pub depends: DependsJson,
        }

        #[derive(serde::Serialize, serde::Deserialize)]
        struct DependsJson {
            pub ping_server: i32, /* Handle ID */
        }

        pub enum Message<'a> {
            NewclientRequest(ftl_autogen::protocols::autopilot::NewclientRequestReader<'a>),

            NewclientReply(ftl_autogen::protocols::autopilot::NewclientReplyReader<'a>),

            PingRequest(ftl_autogen::protocols::ping::PingRequestReader<'a>),

            PingReply(ftl_autogen::protocols::ping::PingReplyReader<'a>),
        }

        use ftl_types::message::MessageBody;
        use ftl_types::message::MessageBuffer;
        use ftl_types::message::MessageInfo;

        impl<'b> MessageBody for Message<'b> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(0); // TODO: remove this
            type Reader<'a> = Message<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<Self::Reader<'a>> {
                match msginfo {
                    ftl_autogen::protocols::autopilot::NewclientRequest::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::autopilot::NewclientRequest::deserialize(
                                buffer, msginfo,
                            )?;
                        Some(Message::NewclientRequest(reader))
                    }

                    ftl_autogen::protocols::autopilot::NewclientReply::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::autopilot::NewclientReply::deserialize(
                                buffer, msginfo,
                            )?;
                        Some(Message::NewclientReply(reader))
                    }

                    ftl_autogen::protocols::ping::PingRequest::MSGINFO => {
                        let reader = ftl_autogen::protocols::ping::PingRequest::deserialize(
                            buffer, msginfo,
                        )?;
                        Some(Message::PingRequest(reader))
                    }

                    ftl_autogen::protocols::ping::PingReply::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::ping::PingReply::deserialize(buffer, msginfo)?;
                        Some(Message::PingReply(reader))
                    }

                    _ => None,
                }
            }
        }
    }

    pub mod pong {
        pub struct Environ {
            pub depends: Depends,
        }

        impl Environ {
            pub fn from_environ_ptr(environ_ptr: *const u8, environ_len: usize) -> Self {
                let environ_bytes =
                    unsafe { ::core::slice::from_raw_parts(environ_ptr, environ_len) };

                #[allow(unused_variables)]
                let environ_json: EnvironJson =
                    serde_json::from_slice(environ_bytes).expect("failed to parse environ JSON");

                let depends = Depends {};

                Self { depends }
            }
        }

        pub struct Depends {}

        #[derive(serde::Serialize, serde::Deserialize)]
        struct EnvironJson {
            pub depends: DependsJson,
        }

        #[derive(serde::Serialize, serde::Deserialize)]
        struct DependsJson {}

        pub enum Message<'a> {
            NewclientRequest(ftl_autogen::protocols::autopilot::NewclientRequestReader<'a>),

            NewclientReply(ftl_autogen::protocols::autopilot::NewclientReplyReader<'a>),

            PingRequest(ftl_autogen::protocols::ping::PingRequestReader<'a>),

            PingReply(ftl_autogen::protocols::ping::PingReplyReader<'a>),
        }

        use ftl_types::message::MessageBody;
        use ftl_types::message::MessageBuffer;
        use ftl_types::message::MessageInfo;

        impl<'b> MessageBody for Message<'b> {
            const MSGINFO: MessageInfo = MessageInfo::from_raw(0); // TODO: remove this
            type Reader<'a> = Message<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo,
            ) -> Option<Self::Reader<'a>> {
                match msginfo {
                    ftl_autogen::protocols::autopilot::NewclientRequest::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::autopilot::NewclientRequest::deserialize(
                                buffer, msginfo,
                            )?;
                        Some(Message::NewclientRequest(reader))
                    }

                    ftl_autogen::protocols::autopilot::NewclientReply::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::autopilot::NewclientReply::deserialize(
                                buffer, msginfo,
                            )?;
                        Some(Message::NewclientReply(reader))
                    }

                    ftl_autogen::protocols::ping::PingRequest::MSGINFO => {
                        let reader = ftl_autogen::protocols::ping::PingRequest::deserialize(
                            buffer, msginfo,
                        )?;
                        Some(Message::PingRequest(reader))
                    }

                    ftl_autogen::protocols::ping::PingReply::MSGINFO => {
                        let reader =
                            ftl_autogen::protocols::ping::PingReply::deserialize(buffer, msginfo)?;
                        Some(Message::PingReply(reader))
                    }

                    _ => None,
                }
            }
        }
    }
}
