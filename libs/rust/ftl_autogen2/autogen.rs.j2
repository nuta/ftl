pub mod ftl_autogen {
    use ftl_api::types as ftl_types;

    use ftl_types::message::MessageSerialize;
    use ftl_types::message::MessageDeserialize;
    use ftl_types::message::MessageBuffer;
    use ftl_types::message::MessageInfo;

    #[derive(Debug)]
    pub enum Message {
        {% for m in messages %}
        {{ m.name }}({{ m.protocol_name }}::{{ m.name }}),
        {% endfor %}
    }

    {% for protocol in protocols %}
    pub mod {{ protocol.name }} {
        #[allow(unused)]
        use super::*;

        {% for m in messages %}
            #[repr(C)]
            #[derive(Debug)]
            pub struct {{ m.name }} {
                {%- for f in m.fields %}
                {%- if f.is_handle %}
                pub {{ f.name }}: {{ f.ty }},
                {%- endfor %}

                {%- for f in m.fields %}
                {%- if not f.is_handle %}
                    pub {{ f.name }}: {{ f.ty }},
                {%- endfor %}
            }

            impl MessageSerialize for {{ m.name }} {
                const MSGINFO: MessageInfo = MessageInfo::from_raw(
                    ({{ m.msgid }} << 14)
                    | ({{ m.num_handles }} << 12)
                    | ::core::mem::size_of::<Self>() as isize,
                );

                fn serialize(self, buffer: &mut MessageBuffer) {
                    // FIXME: Avoid copy entire bytes/str.
                    todo!();
                    // core::ptr::write(buffer.as_mut_ptr() as *mut Self, *self);
                }
            }

            impl MessageDeserialize for {{ m.name }} {
                fn deserialize<'a>(buffer: &'a mut MessageBuffer, msginfo: MessageInfo)
                    -> Option<&'a mut Self> {
                    if msginfo != Self::MSGINFO {
                        return None;
                    }

                    todo!()
                    // Some(unsafe { &mut *(buffer.as_mut_ptr() as *mut Self) })
                }
            }
        {% endfor %}
    }
    {% endfor %}
}
