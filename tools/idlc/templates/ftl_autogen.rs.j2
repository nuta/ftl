//! DO NOT EDIT: This file is auto-generated by ftl_idlc.
#![no_std]
#![feature(const_mut_refs)]
#![feature(const_intrinsic_copy)]
#![feature(const_ptr_write)]

use ftl_types::message::MessageSerialize;
use ftl_types::message::MessageDeserialize;
use ftl_types::message::MessageBuffer;
use ftl_types::message::MessageInfo;
use ftl_types::message::MovedHandle;

pub mod protocols {
    use super::*;

    {% for protocol in protocols %}
    pub mod {{ protocol.name }} {
        use super::*;

        {% for m in protocol.messages %}
        #[repr(C)]
        {% if m.has_bytes_fields %}
        pub struct {{ m.name }}<'a> {
        {% else %}
        pub struct {{ m.name }} {
        {% endif %}
            // TODO: Don't copy whole bytes fields.
            {%- for f in m.fields %}
                {% if not f.is_handle %}
                    pub {{ f.name }}: {{ f.builder_ty }},
                {%- endif %}
            {%- endfor %}

            {%- for f in m.fields %}
                {% if f.is_handle %}
                    pub {{ f.name }}: MovedHandle,
                {% endif %}
            {%- endfor %}
        }

        #[repr(C)]
        struct Raw{{ m.name }} {
            {%- for f in m.fields %}
                {% if not f.is_handle %}
                    pub {{ f.name }}: {{ f.raw_ty }},
                {% endif %}
            {%- endfor %}
        }

        {% if m.has_bytes_fields %}
        impl<'a> MessageSerialize for {{ m.name }}<'a> {
        {% else %}
        impl MessageSerialize for {{ m.name }} {
        {% endif %}
            const MSGINFO: MessageInfo = MessageInfo::from_raw(
                ({{ m.msgid }} << 14)
                | ({{ m.num_handles }} << 12)
                | ::core::mem::size_of::<Raw{{ m.name }}>() as isize,
            );

            fn serialize(self, buffer: &mut MessageBuffer) {
                // TODO: Make this a compile-time assertion.
                debug_assert!(::core::mem::size_of::<{{ m.name }}>() < 1 << 12);

                // The actual serialization is done in this const fn. This is to
                // ensure the serialization can be done with const operations.
                const fn do_serialize(this: {{ m.name }}, buffer: &mut MessageBuffer) {
                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut Raw{{ m.name }};

                    {% for f in m.fields %}
                        {% if f.is_bytes %}
                            unsafe {
                                (*dst).{{ f.name }}.copy_from_slice(&this.{{ f.name }});
                            }
                        {%- elif not f.is_handle %}
                            unsafe {
                                core::ptr::write(&mut (*dst).{{ f.name }}, this.{{ f.name }});
                            }
                        {%- endif %}
                    {%- endfor %}

                    // FIXME: Support multiple handles.
                    debug_assert!(MessageInfo::from_raw({{ m.name }}::MSGINFO.as_raw()).num_handles() <= 1);

                    {%- for f in m.fields %}
                        {% if f.is_handle %}
                            buffer.handles[0] = this.{{ f.name }}.0;
                        {%- endif %}
                    {%- endfor %}

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(this);
                }

                do_serialize(self, buffer)
            }
        }

        {% if m.has_bytes_fields %}
        impl<'m> MessageDeserialize for {{ m.name }}<'m> {
        {% else %}
        impl MessageDeserialize for {{ m.name }} {
        {% endif %}
            type Reader<'a> = {{ m.name }}Reader<'a>;

            fn deserialize<'a>(
                buffer: &'a MessageBuffer,
                msginfo: MessageInfo
            ) -> Option<{{ m.name }}Reader<'a>> {
                if msginfo == Self::MSGINFO {
                    Some({{ m.name }}Reader { buffer })
                } else {
                    None
                }
            }
        }

        pub struct {{ m.name }}Reader<'a> {
            #[allow(dead_code)]
            buffer: &'a MessageBuffer,
        }

        impl<'a> {{ m.name }}Reader<'a> {
            #[allow(dead_code)]
            fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a Raw{{ m.name }} {
                unsafe { &*(buffer as *const _ as *const Raw{{ m.name }}) }
            }

            {% for f in m.fields %}
                {% if f.is_handle %}
                    pub fn {{ f.name }}(&self) -> ftl_types::handle::HandleId { // TODO: return OwnedHandle
                        // FIXME: Support multiple handles.
                        self.buffer.handles[0]
                    }
                {% else %}
                    pub fn {{ f.name }}(&self) -> {{ f.raw_ty }} {
                        let m = self.as_raw(self.buffer);
                        m.{{ f.name }}
                    }
                {% endif %}
            {% endfor %}
        }
        {% endfor %}
    }
    {% endfor %}
}
