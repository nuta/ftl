//! DO NOT EDIT: This file is auto-generated by ftl_idlc.
#![no_std]
#![feature(custom_inner_attributes)] // For #![rustfmt::skip]
#![rustfmt::skip]

use ftl_types::message::MessageBody;
use ftl_types::message::MessageBuffer;
use ftl_types::message::MessageInfo;

pub mod protocols {
    use super::*;

    {% for m in messages %}
    #[repr(C)]
    pub struct {{ m.name }} {
        {%- for f in m.fields %}
        pub {{ f.name }}: {{ f.ty }},
        {%- endfor %}
    }

    // TODO: static_assert for size

    impl MessageBody for {{ m.name }} {
        const MSGINFO: MessageInfo = MessageInfo::from_raw(
            {{ m.msgid }} << 14
            | ::core::mem::size_of::<{{ m.name }}>() as isize,
        );

        type Reader<'a> = {{ m.name }}Reader<'a>;

        fn deserialize<'a>(
            buffer: &'a MessageBuffer,
            msginfo: MessageInfo
        ) -> Option<Self::Reader<'a>> {
            if msginfo == Self::MSGINFO {
                Some({{ m.name }}Reader { buffer })
            } else {
                None
            }
        }
    }

    pub struct {{ m.name }}Reader<'a> {
        #[allow(dead_code)]
        buffer: &'a MessageBuffer,
    }

    impl<'a> {{ m.name }}Reader<'a> {
        #[allow(dead_code)]
        fn as_ref(&self, buffer: &'a MessageBuffer) -> &'a {{ m.name }} {
            unsafe { &*(buffer as *const _ as *const {{ m.name }}) }
        }

        {% for f in m.fields %}
        pub fn {{ f.name }}(&self) -> {{ f.ty }} {
            let m = self.as_ref(self.buffer);
            m.{{ f.name }}
        }
        {% endfor %}
    }
    {% endfor %}
}
